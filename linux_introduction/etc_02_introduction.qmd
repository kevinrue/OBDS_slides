# Talk 2: Introduction to the Linux command line

## Overview

- Linux is a type of computer operating system (OS), like Windows or MacOS, that is part of the Unix 
family of OS

<!--
- Linux is frequently used in high-performance computing and applications e.g. in Computational Biology
-->

<br>
<br> 

:::: {.columns}

::: {.column width="60%"}

- Introduction to the Linux shell 
- Using and getting help with Linux commands 
- Navigating the Linux file system
- Viewing and editing files
- Remote connection a Linux server or cluster
- File properties and permissions
- Manipulating files and directories

:::

::: {.column width="40%"}
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/UNIX-Logo-500x281.jpg")
```

<br>
<br>

```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 250px
## Source: https://1000logos.net/linux-logo/
knitr::include_graphics("img/Symbol-Linux.jpg")
```
:::

::::

## Linux shell - Terminology alert!

<!-- 
Nice explanation in https://www.freecodecamp.org/news/command-line-for-beginners/ and
https://www.freecodecamp.org/news/the-linux-commands-handbook/#introductiontolinuxandshells
-->

- Linux is an Operating System (OS), like MS Windows and macOS, but open source (source code is freely available!) 
- All OS have a  **shell** (a command-line interpreter) for us to communicate with the OS
  + The **shell** takes commands from the keyboard and gives them to the OS to perform
- There are different shells differing in syntax and characteristics

## Linux shell - Terminology alert!

- Most widely used shell for Linux is **Bash** (Bourne Again Shell)
  + Default shell in the OBDS server but others are available for use
- A **terminal emulator** (e.g. Git Bash, macOS Terminal app) is used to interact with the shell, providing the **command-line interface (CLI)**, where user inputs commands
  + The command-line prompt (input field) is indicated by a certain character depending on the OS ($ for Linux)

:::: {.columns}

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_bash.png")
```
:::

::: {.column width="50%"}

```{r, linux_shell_emulator}
#| fig-align: center
#| out-height: 225px
#| out-width: 500px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 2)
knitr::include_graphics("img/linux_shell_emulator.png")
```
:::

::::

## Anatomy of a Linux command

- Basic part/s (<span style="color:red;">\<arrows></span> indicates a variable which should be replaced)
  + \<command>      
  + \<command> \<argument> 
  + \<command> \<options> \<argument> 
  
- Types of commands
  + **Shell builtin** - Built into the shell itself
  + **Executable program** - Any external software in the system path (where OS looks for executable programs)
  + **Alias** - User-defined command built using other commands (To Be Discussed)

```
$ type cd               # ‘type’ shows the type of command
cd is a shell builtin

$ type head
head is /usr/bin/head
      
$ which head            # ‘which’ returns the path of the file to be executed
/usr/bin/head
```

## Linux command options

- Commands have options that modify their functions
  + \<command> \<options> \<argument>
  + Short options start with '-' (TBD)
  + Long options start with '\-\-' (TBD)

<br>

```
$ which head
/usr/bin/head

$ which -a head         # -a to print all matching paths of each argument
/usr/bin/head
/bin/head
```

## Getting help with Linux commands

- Different ways
  + `man` shows manual pages of the command
  ```
  $ man head
  ```
  + Press 'q' to exit
  
```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 800px
## Source: screenshot from jade
knitr::include_graphics("img/man_head.png")
```

## Getting help with Linux commands

- Different ways
   + Commands often come with the help option, `--help`
   ```
   $ head --help
   ```
   + More concise than `man` output

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 600px
## Source: screenshot from jade
knitr::include_graphics("img/help_head.png")
```

## Getting help with Linux commands

- Different ways
  + Google search!
  + Use in combination with command-line ways for more information that is accurate and up to date

```{r}
#| fig-align: center
#| out-height: 350px
#| out-width: 600px
## Source: Google search! :>
knitr::include_graphics("img/google_head.png")
```

## Some useful keyboard shortcuts

- **Tab** - autocomplete (will prompt if ambiguous)
  + Predict rest of word (e.g. command or file path/name) based on first few typed characters
  
```{r}
#| fig-align: center
#| out-height: 100px
#| out-width: 600px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/tab_autocompletion.png")
```

- **Up and down arrows** - Access history of commands
- **Control + c** - Abort current command
- **Control + a** - Go to start of line
- **Control + e** - Go to end of line
- **Control + l** - Clear screen 

<span style="color:green;">**DEMO**</span>

## Linux file system tree

- In Linux, everything is a file organised in a tree structure
- A directory is just a file containing names of other files
- All directories branch off from the **root** ('/') directory
- **home** ('~') is your personal (user) directory

```{r}
#| fig-align: center
#| out-height: 400px
#| out-width: 700px
## Source: https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained
knitr::include_graphics("img/linux_file_tree.png")
```

## Linux commands to navigate the file structure

- Basic commands

```
$ pwd                       # Show present working directory
/home/<user>                # When you log into the OBDS server, the working directory
                              is initially set to the user’s home directory
$ ls                 
Desktop  Documents  Downloads...

$ cd Desktop                # Change directory

$ pwd
/home/<user>/Desktop
```

## Working with Paths 

Path is the location to a file

:::: {.columns}

::: {.column width="40%"}

- There are two types of paths, absolute and relative
- Absolute paths
  + Absolute paths always starts with the root directory ('/')
  + Given by `realpath`
  
    ```
    $ realpath foo
    /home/mthomas/class_stuff/foo
    ```
:::

::: {.column width="60%"}

```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/sample_working_tree.png")
```

:::

::::

## Working with Paths 

:::: {.columns}

::: {.column width="40%"}

- Relative paths 
  + Relative paths are relative to the current working directory
  + Does not start with '/'

    ```
    $ pwd 
    /home/mthomas/class_stuff/foo
    
    $ cd ../bar     # Go to bar
    $ cd ../../bin  # Go to bin
    ```

- Path shortcuts
  + .  (full stop)     current directory 
  + .. (2 full stops)  parent / previous directory
  + ~  (tilde)         home directory
  + /  (forward slash) root directory
  
:::

::: {.column width="60%"}
```{r, sample_working_tree}
#| fig-align: center
#| out-height: 300px
#| out-width: 700px
```
:::

::::

## Working with Paths

- Tips
  + Prompt tells you your current working directory
  
  ```{r, linux_shell_emulator}
  #| fig-align: center
  ```
  + Always use tab autocompletion to avoid typos 
    - Command-line interpreters may figure out whether you need a command or file path
  + `ls` output can be set to be coloured to indicate the type of each file 
    - <span style="color:indigo;">Directory</span>
    - File
    - <span style="color:cyan;">Symbolic link</span> (TBD) 
    - <span style="color:#b84e38;">Compressed file</span> (TBD)
    
## Viewing text files on the command line

- Useful commands
  + \<filename> - input file path or name (if file is in current working directory)

```
$ cat <filename>            # Print the entire file contents to the terminal
                            # If taking a while, interrupt with Control + c
$ head -n 20 <filename>     # Print the first n lines to the terminal (default=10)
$ tail -n 20 <filename>     # Print the last n lines to the terminal (default=10)
$ wc <filename>             # Count the number of characters (-m), lines (-l) etc.
```

- Interactively scroll through files

```
$ more <filename>           # Scroll through a file unidirectionally from top to 
                              bottom
$ less <filename>           # Like more but allows backward movement, "less is more"

                            # Up and down arrow keys to scroll one line up or down
                            # Left and right arrow keys to scroll one screen worth 
                              left or right across contents
                              
                            # Similar to more, use space bar to scroll down one 
                              screen worth of contents
                            # Similar to more, exit anytime with 'q'
                            # Unlike more, reaching end will not terminate 
                              interactive viewer
```

# Coffee break (20 mins)

@sec-Talk2Exercise1

## Remote connection to a Linux server

We will do exercises on the Linux OBDS teaching server so how to connect to it?
<br>

- We can log into a remote target host (e.g. server or cluster) using `ssh`
- SSH (secure shell) is an encrypted network protocol for establishing a secure remote connection to a target host
- Simply put, the protocol uses a username and password to authenticate a user on the target host
  ```
  $ ssh <target username>@<target host>
  ```
  + If prompted for authenticity of host and whether to continue connecting, type 'yes' (usually appears when connecting the first time)
  + This then prompts for the password for the user account on target host 

## Remote connection to a Linux server *via* a jump host

- Sometimes, the connection has to be through a jump (bastion / proxy) host as an intermediary or gateway for extra security

  ```
  $ ssh -J <jump username>@<jump host> <target username>@<target host> 

  # OR

  $ ssh -o ProxyJump=<jump username>@<jump host> <target username>@<target host>
  ```
  + -o - Can be used to give options in the format used in the configuration file (TBD)

- To connect to the OBDS server (obds), we do need to use University VPN and go through the WIMM jump host (bastion.imm.ox.ac.uk)
  ```
  $ ssh -o ProxyJump=<username>@bastion.imm.ox.ac.uk <target username>@obds
  ```
  + If prompted for authenticity of host and whether to continue connecting, type 'yes'
  + **This then prompts for 2 passwords**, 1 for the jump host and 1 for the target host, that should be entered every time you want to connect
  + <span style="color:red;">For people within the University, the username is your SSO for both hosts</span>
  + <span style="color:red;">In our case, the user accounts on bastion and obds are the same!</span>

- <span style="color:red;">Note that we do not always have to go through a jump host!</span>
 
## Remote Connection to a Linux Server

- To logout, use any of the following:
  + Type 'exit' and press the Return key
  + Type 'logout' and press the Return key
  + Press Control + d

## Side note for tomorrow!

- Please download the [FileZilla Client](https://filezilla-project.org/download.php?platform=osx) for tomorrow's lecture

- We will use this program to transfer files between your local machine and a remote target host (e.g. OBDS server)

# Talk 2 Exercise 1 then Lunch break (60 mins)

@sec-Talk2Exercise1

## Changing how you view files using ``ls`` options

:::: {.columns}

::: {.column width="50%"}

- Short options can be bundled
  ```
  $ ls -l -t -a -h -F

  $ ls -ltahF    
  ```
  + -l - Long format, displaying detailed information (e.g. permissions, size, timestamp of latest update)
  + -t - Sort files by modification time (newest first)
  + -a - Show hidden files
  + -h - Human readable numbers
  + -F - Append an indicator to the end of each listed name (e.g. '/' for a directory)

:::

::: {.column width="50%"}

```{r}
#| fig-align: center
#| out-height: 375px
#| out-width: 450px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_options.png")
```

:::

::::

## File properties and permissions

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output_labeled.png")
```

- `ls -l` used to display file permissions

## File permissions - owner

- Linux is a multi-user OS
- So important that access to read, write and execute each file or directory is controlled
- Each file is owned by exactly one user

```{r}
#| fig-align: center
#| out-height: 200px
#| out-width: 915px
## Source: https://1000logos.net/unix-logo/#
knitr::include_graphics("img/ls_long_output.png")
```

## File permissions – group & other

- A **group** is a collection of one or more users
- Each user can be a member of multiple groups 
- A file can be owned by exactly one group
- To see the groups that your user currently belongs to, type:
```
$ groups
```
- The last category that you can assign permissions for is the **other** category
  + Any user that is not the file owner and 
  + is not a member of the group that owns the file
- This allows you to set permissions that will apply to anyone outside of the two control groups
  + Any user that is not the file owner and
  + is not a member of the group that owns the file

## Types of file permissions

- Each permissions category (owner, group and other) can be assigned permissions that restrict their ability to read, write, or execute a file
- For a regular file
  + **Read** permissions are required to read the contents of a file (**open**)
  + **Write** permissions are necessary to **modify** it
  + **Execute** permissions are needed to **run the file** as a program
- For directories
  + **Read** permissions are necessary to **list** the contents of a directory
  + **Write** permissions are required to **modify** the contents of a directory
  + **Execute** permissions allow a user to **navigate** into the directory
- Linux represents these types of permissions using alphabetic or octal notations

## Alphabetic notation

- More verbose and easier to read and write than the octal notation

```{r}
#| fig-align: center
#| out-height: 300px
#| out-width: 900px
## Source: custom-made (obds_sep2023/02_Introduction_to_the_linux_command_line.pptx, slide 18)
knitr::include_graphics("img/alphabetic_notation.png")
```

## Changing file permissions using alphabetic notation

- Most commonly, changes in file permissions are made to
  + Strategically control access
  + Make valuable files (e.g. raw sequencing data) read-only, to avoid accidentally deleting them
  + Make script files executable
  
- Do not change file permissions to give other users access to your own files and directories
- Instead, contact the system administrators to request directories that are set up with shared access for collaborators (e.g. projects in the CCB cluster)
  
## Changing file permissions using alphabetic notation

- We can change file permissions with ``chmod`` using alphabetic notation
- `chmod` <permissions> <file or directory>
  + **u** for user, **g** for group, **o** for other
  + **--** to deny access, **+** to give access
  + **r** for read, **w** for write, **x** for execute
  + **,** (comma) for separating multiple sets of changes 

```
$ chmod u+x,g-w,o-r file1.txt
```
  + u+x - To add execute permission for the user who owns the file 
  + g-w - To remove write permission for the user group assigned to the file 
  + o-r - To remove read permission for every other user 

```
$ chmod go-rwx file1.txt    # Can be bundled together when applying same 
                              permission to user categories      
                              
$ ls -l file1.txt
-rwx------ 1 dsims root 2981 Apr 26  2020 file1.txt
```

## Using octal notation for file permissions

- Octal notation is more compact but takes more practice to read and write
- Each type of permission is assigned a numerical value
  + **4** for **read** permission
  + **2** for **write** permission
  + **1** for **execute** permission
- We sum the numbers for each category to give a single unique number for each combination of permissions
- Each permissions category (owner, group, other) is represented by a number between **0** (no permission) and **7** (all permission)

## Changing file permissions using octal notation

- We can change file permissions with ``chmod`` using octal notation

  ```
  $ chmod 700 file1.txt
  $ ls -l file1.txt
  -rwx------ 1 dsims obds 2981 Apr 26  2021 file1.txt
  ```

- File permissions can be displayed in octal format using ``stat``

  ```
  stat -c "%a: %n" *              # %a: access rights in octal, %n: file name
  755: jupyter_notebooks
  644: mm10.blacklist.bed.gz
  ```
  + -c - use the specified format instead of the default

## Viewing and editing files on the command line using interactive text editors

- No graphical interface or mouse required
- Tools
  + Vim and Emacs 
    - Been around for 40 years, widely used, large number of add-ons
    - Can be heavily customised (e.g. keyword highlighting, code auto-completion)
    - But users need to learn a set of keyboard shortcuts
  + Nano - more basic and so recommended for beginners
- To edit a file, type either one of these
```
$ vim <filename>  
$ emacs <filename>
$ nano <filename>
```

## Working with nano

- The arrow keys can be used to move the cursor through the file
- Common keyboard shortcuts are displayed at the bottom of the editor
  + The ^ symbol represents the Control key
  + For instance, ^X indicates that pressing the Control + x will exit the interactive text editor

- To save edits made to a file:
  + Press Control + x to initiate the exit from the editor
  + When prompted whether to ‘Save modified buffer’, press Y to confirm (N to discard changes)
  + When prompted for the ‘File Name to Write’, immediately press the Return key to use the current
  file name (or edit file name as needed)
  
<span style="color:green;">**DEMO**</span>

## Creating files and directories

<br>

```
$ touch <filename>      # Create new empty file (can create several at a time)
                        # If file exists, will update timestamp to current time
                            
$ nano <filename>       # Open new empty file in nano editor
                        # If file exists, will open file for editing
                                
$ mkdir <dir1>          # Create new directory
$ mkdir <dir1> <dir2>   # Create multiple new directories
```

## Copying, moving and renaming files

<br>

```
$ cp file1 file2                # Copy file to new file
$ cp -n file1 file2             # Do not overwrite if file2 exists
$ cp file1 dir1/                # Copy file to new directory
$ cp -r dir1/ dir2/             # 'cp' needs -r to recursively copy contents of 
                                  directories (empty or not) to a new directory 
                                  (does not need to exist beforehand)
                                # If dir2/ already exists, the copy will be 
                                  created inside dir2/


$ mv file1 file1.csv            # Rename file
$ mv file1 dir1/file.csv        # Move file to new directory and rename 
                                  (-n to not overwrite)
$ mv dir1/ dir2/                # Rename directory, no need for -r
                                # But if dir2/ exists, dir1/ will be moved to dir2/ 
```

## Deleting files & directories 

<br>

```
$ rm file1                              # Remove file
$ rm file1.txt file1.csv file2* *.csv   # Remove multiple files, use wildcard (*)
                                        # Also delete all files whose names start with 
                                          file2 and all files that end with .csv
$ rm -r dir1                            # Remove directory and contents     
$ rm -rv dir1                           # Verbosely display list of files to be removed
$ rmdir dir1                            # Remove empty directory, will raise an 
                                          error if directory is not empty
$ rmdir dir1 dir2                       # Will only remove empty directories
```

- **<span style="color:red;">There is no undo or recycle bin so be careful when using `rm` !</span>**
  + Particularly with -r (recursive) or '*' (wildcard)
  + **<span style="color:green;">Good news</span>**, you can only remove files you have permission to delete
  
- **<span style="color:green;">Make sure to try the commands you have seen on your own later!</span>**

## Using wildcards (*)

- Wildcards are special characters that match one or more characters in filenames
- Therefore they are used to specify groups of file names matching a pattern
- Main wildcards
  + \* - Matches any sequence of characters 
  + ? - Matches any single character

- Example globs (term used in Linux):
```
$ ls *.jpg                      # Lists all files with the .jpg extension
$ ls sample1*                   # Lists all files which start with sample1
$ ls *temp*                     # Lists all files with temp anywhere in the file name
$ file?.*                       # Multiple wildcards can be used in the same pattern
```

## Hard & symbolic links to files and directories

- In cases when you need files to be in multiple places, links to files can be used instead of copying files in multiple places
  + Saves space
  + For more organised and logical file structures
  + Easier to keep files up to date across different places
- A **hard link** is a pointer to the data itself (spot on the hard drive)
- A **symbolic link** (soft link or abbreviated symlinks) is a file that contains a text pointer to the path of a file or directory
- Symbolic links overcome disadvantages of hard links:
  + Deleting all the hard links to a file will effectively delete the file itself
  + Hard links cannot span physical devices (a server or cluster can have multiple disks)
  + Hard links cannot reference directories but only files
- The advantage of hard links is that they remain working even when they are moved
- Symbolic link becomes unusable if original file is moved or deleted unless the path it points to is updated

## Hard & symbolic links to files and directories

- Symbolic links can point to target files using absolute or relative paths (relative to location of symlink)
  + With absolute paths, symlink will continue to point to the same location even if the symlink itself is moved
  + With relative paths, symlink will point to a new location if the symlink itself is moved (relative to new location of symlink)

```
$ ln file1 link1.csv            # Create hard link
$ ln -s file1 link1.csv         # Create symbolic link for a file
$ ln -s dir1 link1              # Create symbolic link for a directory
```

## File types and extensions
 
- Files can be:
  + Plain text - contain only characters of readable materials that can be displayed by most text editors
  + Binary - not plain text (e.g. compiled programs, images)
- Many files use a standardised internal organisation called a file format
  + Having a standard allows for consistency
  + Enables software to easily extract defined information
- Many programs make use of file extensions in their input and output file names:
  + To parse the contents of input files according to their format 
  + To indicate the format used to write the contents of their output files

- Good habit to use an appropriate file extension even just using the generic '.txt' to indicate that the file contains plain text information

## File types and extensions

- There are several biological file formats
  + .fasta - biological sequence information
  + .fastq (.fq) - sequence information with quality scores
  + .sam, .bam - alignments of sequences to a reference genome
  + .gtf, .bed - genomic coordinates of sequence features (e.g. exons, peaks)
- In bioinformatics, binary file formats are commonly used to store compressed versions of equivalent plain text files (e.g. the SAM and BAM file formats).

- Renaming a file and changing its file extension will not cause any error if the new file extension does not match the format of the contents
- Mismatch between file extension and format of contents may only be detected when the file is actively used by a program that relies on the file extension

# Coffee break (20 mins) then Talk 2 Exercise 2

@sec-Talk2Exercise2

<br>

Talk 2 Advanced Exercise 3 - Octal permissions

## Useful links

- [Classic SysAdmin: The Linux Filesystem Explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained)

## References

```{r}
#| results: asis
PrintBibliography(bib)
```

